{"version":3,"sources":["../src/make_fixture.ts"],"sourcesContent":["export const make_fixture = {\n  /**\n   * A lot of properties are syntax sugar with purpose\n   * to simplify process of constructing pretty difficult\n   * internal data-structure for fixture. Also it may\n   * help to understand main ideas and purposes with which\n   * it was developed.\n   */\n  start_builder_chain: {\n    /**\n     * The shape of the data source\n     *\n     * This type is represent the all values,\n     * that can be used in dto, entities, models, etc.\n     * which will be produced from same source.\n     * Example:\n     * The single data-set associated with user can be used\n     * for user creation, user updates, view full or compact\n     * user's representation, etc.\n     * ```\n     * make_fixture.for_data_type<{\n     *   id: string;\n     *   name: string;\n     *   age: number;\n     * }>() /// ...rest code\n     * ```\n     * #### Important!\n     * **This is generic type, that you should provide and nothing more**\n     */\n    for_data_type: <\n      T_data extends\n        | Record<string, any>\n        | _T_help_message_for_data_type = _T_help_message_for_data_type,\n    >(\n      ..._warning: T_data extends _T_help_message_for_data_type\n        ? [_T_help_message_for_data_type, never]\n        : []\n    ) => {\n      return {\n        /**\n         * Next generic only helper, that should extend\n         * `string` type, for example:\n         * ```\n         * .with_possible_tags<\"all\", \"verified_only\", \"men\">\n         * ```\n         * These tags will be used to mark fixtures and so have ability\n         * to group them by some criteria. Because this is tag - fixture\n         * can be belong to many groups at once.\n         *\n         * **At this moment though - you should simply register all possible variants\n         * for better typescript inference**\n         */\n        with_possible_tags: (<\n          T_tags extends (\n            | string\n            | _T_help_message_with_possible_tags\n          ) = _T_help_message_with_possible_tags,\n        >(\n          ..._warning: T_tags extends _T_help_message_with_possible_tags | \"\"\n            ? [_T_help_message_with_possible_tags, never]\n            : []\n        ) => {\n          type TD = Partial<\n            Exclude<T_data, _T_help_message_for_data_type | undefined>\n          >;\n\n          type TT = Exclude<T_tags, _T_help_message_with_possible_tags | \"\">;\n\n          return {\n            /**\n             * This is object, in which each property is represented\n             * particular dto/entity/view or state of your data.\n             * For example data, associated with user can contain many\n             * properties, but during creation you skip `id` and so on.\n             * The value of each property is a function - that should\n             * transform initial data to some form.\n             * Example:\n             * ```\n             * {\n             *    create_user_dto: (data) => ({ : data.email }),\n             *    update_user_dto: (data) => ([data.id, ])\n             * }\n             * ```\n             */\n            data_can_be_transformed_into_such_views: <\n              T_transformer extends Record<\n                string,\n                (d: TD, ...params: any[]) => any\n              >,\n            >(transformer: T_transformer) => {\n              type T_as_arr = {\n                [k in keyof T_transformer]: (\n                  ...params: FirstRest<Parameters<T_transformer[k]>>[1]\n                ) => () => ReturnType<T_transformer[k]>[];\n              };\n              type T_as = {\n                [k in keyof T_transformer]: (\n                  ...params: FirstRest<Parameters<T_transformer[k]>>[1]\n                ) => () => ReturnType<T_transformer[k]>;\n              };\n              type _T_One_By_Name = {\n                /**\n                 * Generate representation of data, that you declared during build.\n                 * You will get not directly this representation, function: `() => representation`.\n                 * So until logic of the representation is the same it will automatically produce\n                 * it with actual values from data-source.\n                 */\n                as: T_as;\n                /**\n                 * Mark this fixture with some tags.\n                 * No matter does it is already marked by them or not, but\n                 * from now it will.\n                 */\n                add_to_more_tags: (...tag: TT[]) => void;\n                /**\n                 * Remove from fixture associations with ome tags.\n                 * No matter does it is already marked by them or not, but\n                 * from not it will not.\n                 */\n                remove_from_tags: (...tag: TT[]) => void;\n                /**\n                 * The only one correct way to update fixture's data.\n                 */\n                update_data_source: (\n                  /**\n                   * Your custom logic how to produce new data from previous varian.\n                   * Because it is function - you can do this with any custom logic\n                   * or even skip update because of some condition, though in such case you should\n                   * return input as it is...\n                   * So the rule is simple - data will be updated to whatever your function return.\n                   */\n                  update_logic: (d: TD) => TD,\n                ) => void;\n              };\n              return {\n                /**\n                 * Complete building fixture-set by providing\n                 * implementation.\n                 * Each property is fixture-wrapper, with fixture itself\n                 * and all tags associated with this fixture.\n                 */\n                build: <\n                  T_fixture_set extends Record<\n                    string,\n                    { fixture: TD; tags: TT[] }\n                  >,\n                >(fixture_set: T_fixture_set): {\n                  /**\n                   * Api to manage one unique fixture.\n                   */\n                  one_by_name: (name: keyof T_fixture_set) => _T_One_By_Name;\n                  /**\n                   * Api for manage list of fixtures with some tag.\n                   */\n                  many_with_tags: (...tags: [TT, ...TT[]]) => {\n                    to_array_of_fixtures: () => _T_One_By_Name[];\n                    /**\n                     * Generate array with representations for all fixtures marked by some tag.\n                     * It is also will return not directly array with these views but function,\n                     * that will produce it. This will guarantee, that on each call\n                     * the representations will have actual values from data-source.\n                     */\n                    as: T_as_arr;\n                    /**\n                     * Possibility to update all fixtures associated with\n                     * actual tag. Because this is function, any logic, including\n                     * skip during update can be implement.\n                     * The only rule - return value is one that will become new data-source.\n                     */\n                    foreach_update_data_source: (\n                      /**\n                       * Custom logic of update, that will be applied to all\n                       * fixtures under the current tag.\n                       */\n                      update_logic: (d: TD) => TD,\n                    ) => void;\n                  };\n                } => {\n                  let last_id = Date.now();\n                  const db = Object\n                    .entries(fixture_set)\n                    .reduce(\n                      (acc, [name, { fixture, tags }]) => {\n                        const id = ++last_id;\n                        acc.id_fixture.set(id, fixture);\n                        acc.name_tag_id.set(\n                          name,\n                          new Map(tags.map((t) => [t, id])),\n                        );\n                        acc.id_name.set(id, name);\n                        acc.name_id.set(name, id);\n                        for (const tag of tags) {\n                          (acc.tag_name_id.get(tag) ||\n                            acc.tag_name_id.set(tag, new Map()).get(tag)!)\n                            .set(name, id);\n                        }\n\n                        return acc;\n                      },\n                      {\n                        id_fixture: new Map<number, TD>(),\n                        name_id: new Map<string, number>(),\n                        id_name: new Map<number, string>(),\n                        name_tag_id: new Map<\n                          string,\n                          Map<string, number>\n                        >(),\n                        tag_name_id: new Map<\n                          string,\n                          Map<string, number>\n                        >(),\n                      },\n                    );\n\n                  const one_by_name = (name: keyof T_fixture_set) => ({\n                    add_to_more_tags: (...tags: string[]) =>\n                      tags.forEach((tag) => {\n                        const fixture = db.name_id.get(name as string)!; /// 100% exists because all fixtures are provided at once;\n                        (db.name_tag_id.get(name as string) ||\n                          db.name_tag_id.set(name as string, new Map())\n                            .get(name as string)!)\n                          .set(\n                            tag,\n                            fixture,\n                          );\n                        (db.tag_name_id.get(tag) ||\n                          db.tag_name_id.set(tag, new Map()).get(tag)!)\n                          .set(\n                            name as string,\n                            fixture,\n                          );\n                      }),\n                    remove_from_tags: (...tags: string[]) =>\n                      tags.forEach((tag) => {\n                        db.name_tag_id.get(name as string)!.delete(tag);\n                        db.tag_name_id.get(tag)!.delete(name as string);\n                      }),\n                    update_data_source: (logic: Function) => {\n                      const id = db.name_id.get(name as string)!;\n                      const fixture = db.id_fixture.get(id)!;\n                      const fresh = logic(\n                        fixture,\n                      );\n                      db.id_fixture.set(id, fresh);\n                    },\n                    as: Object.entries(transformer).reduce((acc, [k, v]) => {\n                      acc[k as keyof T_transformer] = (...args) => () => {\n                        const id = db.name_id.get(name as string)!;\n                        return v(\n                          db.id_fixture.get(id)!,\n                          ...args,\n                        );\n                      };\n                      return acc;\n                    }, {} as T_as),\n                  });\n\n                  return {\n                    one_by_name,\n                    many_with_tags: (...tags: [TT, ...TT[]]) => ({\n                      to_array_of_fixtures: () => {\n                        const ids_by_tag = [] as Set<number>[];\n                        for (const tag of tags) {\n                          const ids = db.tag_name_id.get(tag)?.values().map((\n                            id,\n                          ) => id) || [];\n                          ids_by_tag.push(new Set(ids));\n                        }\n                        if (ids_by_tag.length) {\n                          const with_all_tags_ids = ids_by_tag.reduce((a, b) =>\n                            a.intersection(b)\n                          );\n\n                          const result: _T_One_By_Name[] = [];\n                          with_all_tags_ids.values().toArray().forEach((\n                            id,\n                          ) => {\n                            const name = db.id_name.get(id);\n                            if (name) {\n                              const f = one_by_name(name);\n                              result.push(f);\n                            }\n                          });\n\n                          return result;\n                        } else {\n                          return [];\n                        }\n                      },\n                      as: Object.entries(transformer).reduce((acc, [k, fn]) => {\n                        acc[k as keyof T_transformer] = () => (...args) => {\n                          const ids_by_tag = [] as Set<number>[];\n                          for (const tag of tags) {\n                            const ids = db.tag_name_id.get(tag)?.values().map((\n                              id,\n                            ) => id) || [];\n                            ids_by_tag.push(new Set(ids));\n                          }\n                          if (ids_by_tag.length) {\n                            const with_all_tags_ids = ids_by_tag.reduce((\n                              a,\n                              b,\n                            ) => a.intersection(b));\n\n                            return with_all_tags_ids.values().map((id) =>\n                              fn(db.id_fixture.get(id)!, ...args)\n                            ).toArray();\n                          }\n\n                          return [];\n                        };\n                        return acc;\n                      }, {} as T_as_arr),\n                      foreach_update_data_source: (logic) => {\n                        const ids_by_tag = [] as Set<number>[];\n                        for (const tag of tags) {\n                          const ids = db.tag_name_id.get(tag)?.values().map((\n                            id,\n                          ) => id) || [];\n                          ids_by_tag.push(new Set(ids));\n                        }\n                        if (ids_by_tag.length) {\n                          const with_all_tags_ids = ids_by_tag.reduce((\n                            a,\n                            b,\n                          ) => a.intersection(b));\n\n                          with_all_tags_ids.values().forEach((id) => {\n                            const fixture = db.id_fixture.get(id)!;\n                            db.id_fixture.set(id, logic(fixture));\n                          });\n                        }\n                      },\n                    }),\n                  };\n                },\n              };\n            },\n          };\n        }),\n      };\n    },\n  },\n};\n\ntype FirstRest<T> = T extends [infer First, ...infer Rest] ? [First, Rest]\n  : never;\ntype _T_help_message_for_data_type =\n  \"ERROR: Explicit generic is missing! Should be something like: for_data_type<{...}>()\";\ntype _T_help_message_with_possible_tags =\n  \"ERROR: Explicit generic is missing! Should be something like: with_possible_tags<['example', 'demo', 'tip']>()\";\n"],"mappings":"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","names":["make_fixture_exports","__export","make_fixture","__toCommonJS","_warning","transformer","fixture_set","last_id","db","acc","name","fixture","tags","id","t","tag","one_by_name","logic","fresh","k","v","args","_a","ids_by_tag","ids","with_all_tags_ids","a","b","result","fn"]}